{"pages":[{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"},{"title":"","text":"冰冻三尺 非一日之寒 积土成山 非斯须之作 关于我我是张连重，专注于Java开发，同时也是一名摄影爱好者。 博客的内容主要是笔者对于java开发技术的一些开发实践和学习总结，初衷是刻意锻炼，提高自己的技术水平和写作能力；同时也希望分享技术，回馈社区。欢迎大家来交流技术，互相促进。 联系方式E-mail: qinghaihudream@163.comQQ: 1353810395微信","link":"/about/index.html"}],"posts":[{"title":"java 并发编程之JMM&&volatile","text":"电子技术在摩尔定律的指挥下，每隔一段时间就会登上一个新的台阶，现在的CPU早已是多核的天下。服务器拥有多核，个人电脑CPU多核也已是标配.在现代多核的CPU的背景下，催生了并发编程的趋势，并发编程的本质其实就是利用多线程技术，通过并发编程的形式可以将多核CPU的计算能力发挥到极致，性能得到提升。除此之外，面对复杂业务模型(如异步场景)，并行程序会比串行程序更适应业务需求，而并发编程更能吻合这种业务拆分。即使是单核处理器也支持多线程执行代码，CPU通过给每个线程分配CPU时间片来实现这个机制。时间片是CPU分配给各个线程的时间，因为时间片非常短，所以CPU通过不停地切换线程执行，让我们感觉多个线程是同时执行的，时间片一般是几十毫秒(ms)。这里有必要强调下并发与并行的区别。实并发不等于并行:并发指的是多个任务交替进行，而并行则是指真正意义上的“同时进行”。际上，如果系统内只有一个CPU，而使用多线程时，那么真实系统环境下不能并行， 只能通过切换时间片的方式交替进行，而成为并发执行任务。真正的并行也只能出现在拥有多个CPU的系统中。 并发的优点: 充分利用多核CPU的计算能力; 方便进行业务拆分，提升应用性能; 并发带来问题: 高并发场景下，导致频繁的上下文切换 临界区线程安全问题， 并发控制下容易出现死锁，产生死锁就会造成系统功能不可用 JMM模型并发编程的难点，就在于对临界资源的访问控制。而并发控制的相关技术，如volatile、synchronized,lock的理解都与JMM(java memory model)息息相关。下图给出了JMM模型。 主内存主要存储的是Java实例对象，所有线程创建的实例对象都存放在主内存中，不管该实例对象是成员变量还是方法中的本地变量(也称局部变量)，当然也包括了共享的类信息、常量、静态变量。由于是共享数据区域，多条线程对同一个变量进行访问可能会发生线程安全问题。 工作内存主要存储当前方法的所有本地变量信息(工作内存中存储着主内存中的变量副本拷贝)，每个线程只能访问自己的工作内存，即线程中的本地变量对其它线程是不可见的，就算是两个线程执行的是同一段代码，它们也会各自在自己的工作内存中创建属于当前线程的本地变量，当然也包括了字节码行号指示器、相关Native方法的信息。注意由于工作内存是每个线程的私有数据，线程间无法相互访问工作内存，因此存储在工作内存的数据不存在线程安全问题。根据JVM虚拟机规范主内存与工作内存的数据存储类型以及操作方式，对于一个实例对象中的成员方法而言，如果方法中包含本地变量是基本数据类型（boolean,byte,short,char,int,long,float,double），将直接存储在工作内存的帧栈结构中，但倘若本地变量是引用类型，那么该变量的引用会存储在工作内存的帧栈中，而对象实例将存储在主内存(共享数据区域，堆)中。但对于实例对象的成员变量，不管它是基本数据类型或者包装类型(Integer、Double等)还是引用类型，都会被存储到堆区。至于static变量以及类本身相关信息将会存储在主内存中。需要注意的是，在主内存中的实例对象可以被多线程共享，倘若两个线程同时调用了同一个对象的同一个方法，那么两条线程会将要操作的数据拷贝一份到自己的工作内存中，执行完成操作后才刷新到主内存。 并发编程的可见性、 原子性和有序性问题原子性原子性指的是一个操作是不可中断的，即使是在多线程环境下，一个操作一旦开始就不会被其他线程影响。在java中，对基本数据类型的变量的读取和赋值操作是原子性操作有点要注意的是，对于32位系统的来说，long类型数据和double类型数据(对于基本数据类型，byte,short,int,float,boolean,char读写是原子操作)，它们的读写并非原子性的，也就是说如果存在两条线程同时对long类型或者double类型的数据进行读写是存在相互干扰的，因为对于32位虚拟机来说，每次原子读写是32位的，而long和double则是64位的存储单元，这样会导致一个线程在写时，操作完前32位的原子操作后，轮到B线程（操作系统时间轮循）读取时，恰好只读取到了后32位的数据，这样可能会读取到一个既非原值又不是线程修改值的变量，它可能是“半个变量”的数值，即64位数据被两个线程分成了两次读取。但也不必太担心，因为读取到“半个变量”的情况比较少见，至少在目前的商用的虚拟机中，几乎都把64位的数据的读写操作作为原子操作来执行，因此对于这个问题不必太在意，知道这么回事即可。 可见性可见性指的是当一个线程修改了某个共享变量的值，其他线程是否能够马上得知这个修改的值。对于串行程序来说，可见性是不存在的，因为在任何一个操作中修改了某个变量的值，后续的操作中都能读取这个变量值，并且是修改新值（可以认为单线程的工作内存与主内存是一致的）。但在多线程环境中可就不一定了，前面我们分析过，由于线程对共享变量的操作都是线程拷贝到各自的工作内存进行操作后才写回到主内存中的，这就可能存在一个线程A修改了共享变量x的值，还未写回主内存时，另外一个线程B又对主内存中同一个共享变量x进行操作，但此时A线程工作内存中共享变量x对线程B来说并不可见，这种工作内存与主内存同步延迟现象就造成了可见性问题，另外指令重排以及编译器优化也可能导致可见性问题，通过前面的分析，我们知道无论是编译器优化还是处理器优化的重排现象，在多线程环境下，确实会导致程序轮序执行的问题，从而也就导致可见性问题。 有序性有序性是指对于单线程的执行代码，我们总是认为代码的执行是按顺序依次执行的，这样的理解并没有毛病，毕竟对于单线程而言确实如此（CPU在进行指令重排时，能保证在单线程环境下，执行结果不变）。但对于多线程环境，则可能出现乱序现象，因为程序编译成机器码指令后可能会出现指令重排现象，重排后的指令与原指令的顺序未必一致，要明白的是，在Java程序中，倘若在本线程内，所有操作都视为有序行为，如果是多线程环境下，一个线程中观察另外一个线程，所有操作都是无序的，前半句指的是单线程内保证串行语义执行的一致性，后半句则指指令重排现象和工作内存与主内存同步延迟现象。 volatile关键字解析volatile是Java虚拟机提供的轻量级的同步机制。volatile关键字有如下两个作用 保证被volatile修饰的共享变量对所有线程总是可见的，也就是当一个线程修改了一个被volatile修饰共享变量的值，新值总是可以被其他线程立即得知。 禁止指令重排序优化。 可见性的实现，是基于java虚拟机将volatile关键字转化为lock汇编指令，该指令会将缓存行加锁，在缓存一致性协议作用下，新的线程操作临界变量时，必须先将主内存中的数据更新到工作内存。","link":"/2019/11/27/2019-11-27-java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BJMM&&Volatile/"},{"title":"曾士强中国式管理","text":"曾士强中国式管理不想当将军的士兵肯定不是好士兵，我相信绝大部分朋友都是希望某天能走向管理岗位，而不是一味的在最底层靠卖体力卖技术营生。那从现在起，掌握一些管理知识，是非常有必要的。 中国的高校教育，很大程度上，是延续了西方那套二分思维模式，非黑即白。这种思维模式，在搞科学研究时，是非常适合的，毕竟科学容不得半点虚假，追求的也是终极真理。然而，在面临管理问题时，尤其是你是一个中国人，每天面对的也是形形色色被中华文化熏陶成长起来的中国人，在一个法治还在建设全是人情的社会，你还用西方那种二分思维方式，你肯定是要吃亏的。 举个最简单的例子，西方从古希腊时期，就开始提倡辩论文化，他们相信真理越辩越明。然而，在中国，遇到事情，不讲还好，越讲越乱，讲到最后大家都糊涂了。 西方人讲能力，中国人不讲能力。我们讲本事不讲能力。有能力没有本事的人迟早是个问题人物。什么叫本事？有能力还要加上受到大家的欢迎才叫本事。有能力到处标新立异，处处让人家看不顺眼，这个人迟早是个闯祸的人。有能力还要尊重别人，让别人有面子，他就会支持你。 西方二分看待世界，对就是对，错就是错，黑就是黑，白就是白。太极图很好的为我们指出了看待世界，处理关系的方式，那就是三分世界。不追求过阴过阳，而是阴阳协调，讲究合适。 中国式管理，研究的不是科学，而是哲学，中国处理哲学。如果你对中国式管理也感兴趣，曾仕强老师的演讲绝对是最具影响力的，上面的很多理解也只是老师思想的小碎片。下面挑选一些精彩之处，我相信总有些能让你醍醐灌顶之感。 人只有替自己做事才会效率很高的，替别人做事才会拖拖拉拉。组织如果能把团体弄得像一个人一样，效率就高了。毫无疑问，这句话讲出了管理的精髓。但是如何调动一个人的积极性和主动性，曾教授没有讲到。想起韩寒的那句：听了很多的大道理，却依然过不好一生。我们听了很多的“道”，从很少找到“术”，其实“道”和“术”是同样重要的。 我们不是被事情所困惑，我们是被我们自己对事情的看法所困惑。想起佛家的那首经典的楔子：不是风动，不是帆动，是你的心在动。这个世界是一样的，但是因为我们看待世界的角度不一样，导致我们认识的这个世界是不一样的。 中国式管理，讲起来就是水的管理。和美国式管理偏向火的管理颇为不同。我们主张以柔克刚，先礼后兵，继旧开新，生生不息，无一不和水有关。真的是这样的。中国人讲求面子工程，不给面子一定不行的。 结果不重要，原因、动机才重要。这句话很有意思，因为我们都是听过“对结果负责”这句话，但是曾教授反而说“结果不重要，原因、动机才重要”，我的理解是：做正确的事情比正确的做事要重要的多；如果方向对了，即使慢一点，终归会到达终点的。 中国人要走不会跟你讲真话的。他不是骗你，而是给你面子。好聚好散。人不可以欺骗，但是经常不能说真心话。说真心话你就更惨，比欺骗更惨。真的是这样的，所有说出要离职的人，给出的原因通常不是真正的原因，因为中国人真的需要留下“面子”。 曾仕强老师的《中国式管理》资源链接地址https://pan.baidu.com/s/1l0kJah9Wkam8CSLaGq4bvw 密码:xaf6","link":"/2019/08/27/2019-08-27-%E6%9B%BE%E5%A3%AB%E5%BC%BA%E4%B8%AD%E5%9B%BD%E5%BC%8F%E7%AE%A1%E7%90%86/"},{"title":"Git指令整理","text":"随便整理的一些自用的Git指令 GitHub创建仓库提示代码echo &quot;# 项目名&quot; &gt;&gt; README.md git init git add README.md git commit -m &quot;first commit&quot; git remote add origin git@github.com:qiubaiying/项目名.git git push -u origin master若仓库存在直接push git remote add origin git@github.com:qiubaiying/test.git git push -u origin master常用操作创建仓库（初始化）在当前指定目录下创建 git init 新建一个仓库目录 git init [project-name] 克隆一个远程项目 git clone [url]添加文件到缓存区添加所有变化的文件 git add . 添加名称指定文件 git add text.txt配置设置提交代码时的用户信息 git config [--global] user.name &quot;[name]&quot; git config [--global] user.email &quot;[email address]&quot;提交提交暂存区到仓库区 git commit -m &quot;msg&quot; # 提交暂存区的指定文件到仓库区 $ git commit [file1] [file2] ... -m [message] # 提交工作区自上次commit之后的变化，直接到仓库区 $ git commit -a # 提交时显示所有diff信息 $ git commit -v # 使用一次新的commit，替代上一次提交 # 如果代码没有任何新变化，则用来改写上一次commit的提交信息 $ git commit --amend -m [message] # 重做上一次commit，并包括指定文件的新变化 $ git commit --amend [file1] [file2] ...远程同步# 下载远程仓库的所有变动 $ git fetch [remote] # 显示所有远程仓库 $ git remote -v # 显示某个远程仓库的信息 $ git remote show [remote] # 增加一个新的远程仓库，并命名 $ git remote add [shortname] [url] # 取回远程仓库的变化，并与本地分支合并 $ git pull [remote] [branch] # 上传本地指定分支到远程仓库 $ git push [remote] [branch] # 强行推送当前分支到远程仓库，即使有冲突 $ git push [remote] --force # 推送所有分支到远程仓库 $ git push [remote] --all分支# 列出所有本地分支 $ git branch # 列出所有远程分支 $ git branch -r # 列出所有本地分支和远程分支 $ git branch -a # 新建一个分支，但依然停留在当前分支 $ git branch [branch-name] # 新建一个分支，并切换到该分支 $ git checkout -b [branch] # 新建一个分支，指向指定commit $ git branch [branch] [commit] # 新建一个分支，与指定的远程分支建立追踪关系 $ git branch --track [branch] [remote-branch] # 切换到指定分支，并更新工作区 $ git checkout [branch-name] # 切换到上一个分支 $ git checkout - # 建立追踪关系，在现有分支与指定的远程分支之间 $ git branch --set-upstream [branch] [remote-branch] # 合并指定分支到当前分支 $ git merge [branch] # 选择一个commit，合并进当前分支 $ git cherry-pick [commit] # 删除分支 $ git branch -d [branch-name] # 删除远程分支 $ git push origin --delete [branch-name] $ git branch -dr [remote/branch]标签Tags添加标签 在当前commit git tag -a v1.0 -m &apos;xxx&apos; 添加标签 在指定commit git tag v1.0 [commit] 查看 git tag 删除 git tag -d V1.0 删除远程tag git push origin :refs/tags/[tagName] 推送 git push origin --tags 拉取 git fetch origin tag V1.0 新建一个分支，指向某个tag git checkout -b [branch] [tag]查看信息# 显示有变更的文件 $ git status # 显示当前分支的版本历史 $ git log # 显示commit历史，以及每次commit发生变更的文件 $ git log --stat # 搜索提交历史，根据关键词 $ git log -S [keyword] # 显示某个commit之后的所有变动，每个commit占据一行 $ git log [tag] HEAD --pretty=format:%s # 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件 $ git log [tag] HEAD --grep feature # 显示某个文件的版本历史，包括文件改名 $ git log --follow [file] $ git whatchanged [file] # 显示指定文件相关的每一次diff $ git log -p [file] # 显示过去5次提交 $ git log -5 --pretty --oneline # 显示所有提交过的用户，按提交次数排序 $ git shortlog -sn # 显示指定文件是什么人在什么时间修改过 $ git blame [file] # 显示暂存区和工作区的差异 $ git diff # 显示暂存区和上一个commit的差异 $ git diff --cached [file] # 显示工作区与当前分支最新commit之间的差异 $ git diff HEAD # 显示两次提交之间的差异 $ git diff [first-branch]...[second-branch] # 显示今天你写了多少行代码 $ git diff --shortstat &quot;@{0 day ago}&quot; # 显示某次提交的元数据和内容变化 $ git show [commit] # 显示某次提交发生变化的文件 $ git show --name-only [commit] # 显示某次提交时，某个文件的内容 $ git show [commit]:[filename] # 显示当前分支的最近几次提交 $ git reflog撤销# 恢复暂存区的指定文件到工作区 $ git checkout [file] # 恢复某个commit的指定文件到暂存区和工作区 $ git checkout [commit] [file] # 恢复暂存区的所有文件到工作区 $ git checkout . # 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变 $ git reset [file] # 重置暂存区与工作区，与上一次commit保持一致 $ git reset --hard # 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变 $ git reset [commit] # 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致 $ git reset --hard [commit] # 重置当前HEAD为指定commit，但保持暂存区和工作区不变 $ git reset --keep [commit] # 新建一个commit，用来撤销指定commit # 后者的所有变化都将被前者抵消，并且应用到当前分支 $ git revert [commit] # 暂时将未提交的变化移除，稍后再移入 $ git stash $ git stash pop其他# 生成一个可供发布的压缩包 $ git archives","link":"/2019/11/23/2019-11-23-Git%E6%8C%87%E4%BB%A4%E6%95%B4%E7%90%86/"},{"title":"Spring ioc之深入理解IOC","text":"在一开始学习 Spring 的时候，我们就接触 IoC 了，作为 Spring 第一个最核心的概念，我们在解读它源码之前一定需要对其有深入的认识，本篇为Spring系列博客的第一篇博文，主要介绍 IoC 基本概念和各个组件。 IOC理论IoC 全称为 Inversion of Control，翻译为 “控制反转”，它还有一个别名为 DI（Dependency Injection）,即依赖注入。 如何理解“控制反转”好呢？理解好它的关键在于我们需要回答如下四个问题： 谁控制谁 控制什么 为何是反转 哪些方面反转了 在回答这四个问题之前，我们先看 IOC 的定义： 所谓 IOC ，就是由 Spring IOC 容器来负责对象的生命周期和对象之间的关系 上面这句话是整个 IoC 理论的核心。如何来理解这句话？我们引用一个例子来走阐述（看完该例子上面四个问题也就不是问题了）。 已找女朋友为例（对于程序猿来说这个值得探究的问题）。一般情况下我们是如何来找女朋友的呢？首先我们需要根据自己的需求（漂亮、身材好、性格好）找一个妹子，然后到处打听她的兴趣爱好、微信、电话号码，然后各种投其所好送其所要，最后追到手。如下： 123456789101112131415161718192021222324/** * 年轻小伙子 */public class YoungMan { private BeautifulGirl beautifulGirl; YoungMan(){ // 可能你比较牛逼，指腹为婚 // beautifulGirl = new BeautifulGirl(); } public void setBeautifulGirl(BeautifulGirl beautifulGirl) { this.beautifulGirl = beautifulGirl; } public static void main(String[] args){ YoungMan you = new YoungMan(); BeautifulGirl beautifulGirl = new BeautifulGirl(\"你的各种条件\"); beautifulGirl.setxxx(\"各种投其所好\"); // 然后你有女票了 you.setBeautifulGirl(beautifulGirl); }} 这就是我们通常做事的方式，如果我们需要某个对象，一般都是采用这种直接创建的方式(new BeautifulGirl())，这个过程复杂而又繁琐，而且我们必须要面对每个环节，同时使用完成之后我们还要负责销毁它，在这种情况下我们的对象与它所依赖的对象耦合在一起。 其实我们需要思考一个问题？我们每次用到自己依赖的对象真的需要自己去创建吗？我们知道，我们依赖对象其实并不是依赖该对象本身，而是依赖它所提供的服务，只要在我们需要它的时候，它能够及时提供服务即可，至于它是我们主动去创建的还是别人送给我们的，其实并不是那么重要。再说了，相比于自己千辛万苦去创建它还要管理、善后而言，直接有人送过来是不是显得更加好呢？ 这个给我们送东西的“人” 就是 IoC，在上面的例子中，它就相当于一个婚介公司，作为一个婚介公司它管理着很多男男女女的资料，当我们需要一个女朋友的时候，直接跟婚介公司提出我们的需求，婚介公司则会根据我们的需求提供一个妹子给我们，我们只需要负责谈恋爱，生猴子就行了。你看，这样是不是很简单明了。 诚然，作为婚介公司的 IoC 帮我们省略了找女朋友的繁杂过程，将原来的主动寻找变成了现在的被动接受（符合我们的要求），更加简洁轻便。你想啊，原来你还得鞍马前后，各种巴结，什么东西都需要自己去亲力亲为，现在好了，直接有人把现成的送过来，多么美妙的事情啊。所以，简单点说，IoC 的理念就是让别人为你服务. 在没有引入 IoC 的时候，被注入的对象直接依赖于被依赖的对象，有了 IoC 后，两者及其他们的关系都是通过 Ioc Service Provider 来统一管理维护的。被注入的对象需要什么，直接跟 IoC Service Provider 打声招呼，后者就会把相应的被依赖对象注入到被注入的对象中，从而达到 IOC Service Provider 为被注入对象服务的目的。所以 IoC 就是这么简单！原来是需要什么东西自己去拿，现在是需要什么东西让别人（IOC Service Provider）送过来 现在在看上面那四个问题，答案就显得非常明显了: 谁控制谁：在传统的开发模式下，我们都是采用直接 new 一个对象的方式来创建对象，也就是说你依赖的对象直接由你自己控制，但是有了 IOC 容器后，则直接由 IoC 容器来控制。所以“谁控制谁”，当然是 IoC 容器控制对象。 控制什么：控制对象。 为何是反转：没有 IoC 的时候我们都是在自己对象中主动去创建被依赖的对象，这是正转。但是有了 IoC 后，所依赖的对象直接由 IoC 容器创建后注入到被注入的对象中，依赖的对象由原来的主动获取变成被动接受，所以是反转。 哪些方面反转了：所依赖对象的获取被反转了。 妹子有了，但是如何拥有妹子呢？这也是一门学问。 可能你比较牛逼，刚刚出生的时候就指腹为婚了。 大多数情况我们还是会考虑自己想要什么样的妹子，所以还是需要向婚介公司打招呼的。 还有一种情况就是，你根本就不知道自己想要什么样的妹子，直接跟婚介公司说，我就要一个这样的妹子。 所以，IOC Service Provider 为被注入对象提供被依赖对象也有如下几种方式：构造方法注入、stter方法注入、接口注入。 构造器注入 构造器注入，顾名思义就是被注入的对象通过在其构造方法中声明依赖对象的参数列表，让外部知道它需要哪些依赖对象。 123YoungMan(BeautifulGirl beautifulGirl){ this.beautifulGirl = beautifulGirl;} 构造器注入方式比较直观，对象构造完毕后就可以直接使用，这就好比你出生你家里就给你指定了你媳妇。 setter 方法注入 对于 JavaBean 对象而言，我们一般都是通过 getter 和 setter 方法来访问和设置对象的属性。所以，当前对象只需要为其所依赖的对象提供相对应的 setter 方法，就可以通过该方法将相应的依赖对象设置到被注入对象中。如下： 1234567public class YoungMan { private BeautifulGirl beautifulGirl; public void setBeautifulGirl(BeautifulGirl beautifulGirl) { this.beautifulGirl = beautifulGirl; }} 相比于构造器注入，setter 方式注入会显得比较宽松灵活些，它可以在任何时候进行注入（当然是在使用依赖对象之前），这就好比你可以先把自己想要的妹子想好了，然后再跟婚介公司打招呼，你可以要林志玲款式的，赵丽颖款式的，甚至凤姐哪款的，随意性较强。 接口方式注入 接口方式注入显得比较霸道，因为它需要被依赖的对象实现不必要的接口，带有侵入性。一般都不推荐这种方式。 各个组件 该图为 ClassPathXmlApplicationContext 的类继承体系结构，虽然只有一部分，但是它基本上包含了 IOC 体系中大部分的核心类和接口。 下面我们就针对这个图进行简单的拆分和补充说明。 Resource体系 Resource，对资源的抽象，它的每一个实现类都代表了一种资源的访问策略，如ClasspathResource 、 URLResource ，FileSystemResource 等。 有了资源，就应该有资源加载，Spring 利用 ResourceLoader 来进行统一资源加载. BeanFactory 体系 BeanFactory 是一个非常纯粹的 bean 容器，它是 IOC 必备的数据结构，其中 BeanDefinition 是她的基本结构，它内部维护着一个 BeanDefinition map ，并可根据 BeanDefinition 的描述进行 bean 的创建和管理。 BeanFacoty 有三个直接子类 ListableBeanFactory、HierarchicalBeanFactory 和 AutowireCapableBeanFactory，DefaultListableBeanFactory 为最终默认实现，它实现了所有接口。 Beandefinition 体系 BeanDefinition 用来描述 Spring 中的 Bean 对象。 BeandefinitionReader体系 BeanDefinitionReader 的作用是读取 Spring 的配置文件的内容，并将其转换成 Ioc 容器内部的数据结构：BeanDefinition。 ApplicationContext体系 这个就是大名鼎鼎的 Spring 容器，它叫做应用上下文，与我们应用息息相关，它继承 BeanFactory，所以它是 BeanFactory 的扩展升级版，如果BeanFactory 是屌丝的话，那么 ApplicationContext 则是名副其实的高富帅。由于 ApplicationContext 的结构就决定了它与 BeanFactory 的不同，其主要区别有： 继承 MessageSource，提供国际化的标准访问策略。 继承 ApplicationEventPublisher ，提供强大的事件机制。 扩展 ResourceLoader，可以用来加载多个 Resource，可以灵活访问不同的资源。 对 Web 应用的支持。","link":"/2019/11/25/2019-11-25-Spring%20ioc%E4%B9%8B%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ioc/"}],"tags":[{"name":"JMM","slug":"JMM","link":"/tags/JMM/"},{"name":"volatile","slug":"volatile","link":"/tags/volatile/"},{"name":"曾士强","slug":"曾士强","link":"/tags/%E6%9B%BE%E5%A3%AB%E5%BC%BA/"},{"name":"中国式管理","slug":"中国式管理","link":"/tags/%E4%B8%AD%E5%9B%BD%E5%BC%8F%E7%AE%A1%E7%90%86/"},{"name":"终端","slug":"终端","link":"/tags/%E7%BB%88%E7%AB%AF/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"ioc","slug":"ioc","link":"/tags/ioc/"},{"name":"Spring","slug":"Spring","link":"/tags/Spring/"}],"categories":[{"name":"并发编程","slug":"并发编程","link":"/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"name":"资料","slug":"资料","link":"/categories/%E8%B5%84%E6%96%99/"},{"name":"git","slug":"git","link":"/categories/git/"},{"name":"Spring","slug":"Spring","link":"/categories/Spring/"}]}