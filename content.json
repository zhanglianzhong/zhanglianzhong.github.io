{"pages":[{"title":"tags","text":"","link":"/tags/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"","text":"冰冻三尺 非一日之寒 积土成山 非斯须之作 关于我我是张连重，专注于Java开发，同时也是一名摄影爱好者。 博客的内容主要是笔者对于java开发技术的一些开发实践和学习总结，初衷是刻意锻炼，提高自己的技术水平和写作能力；同时也希望分享技术，回馈社区。欢迎大家来交流技术，互相促进。 联系方式E-mail: qinghaihudream@163.comQQ: 1353810395微信","link":"/about/index.html"}],"posts":[{"title":"曾士强中国式管理","text":"曾士强中国式管理不想当将军的士兵肯定不是好士兵，我相信绝大部分朋友都是希望某天能走向管理岗位，而不是一味的在最底层靠卖体力卖技术营生。那从现在起，掌握一些管理知识，是非常有必要的。 中国的高校教育，很大程度上，是延续了西方那套二分思维模式，非黑即白。这种思维模式，在搞科学研究时，是非常适合的，毕竟科学容不得半点虚假，追求的也是终极真理。然而，在面临管理问题时，尤其是你是一个中国人，每天面对的也是形形色色被中华文化熏陶成长起来的中国人，在一个法治还在建设全是人情的社会，你还用西方那种二分思维方式，你肯定是要吃亏的。 举个最简单的例子，西方从古希腊时期，就开始提倡辩论文化，他们相信真理越辩越明。然而，在中国，遇到事情，不讲还好，越讲越乱，讲到最后大家都糊涂了。 西方人讲能力，中国人不讲能力。我们讲本事不讲能力。有能力没有本事的人迟早是个问题人物。什么叫本事？有能力还要加上受到大家的欢迎才叫本事。有能力到处标新立异，处处让人家看不顺眼，这个人迟早是个闯祸的人。有能力还要尊重别人，让别人有面子，他就会支持你。 西方二分看待世界，对就是对，错就是错，黑就是黑，白就是白。太极图很好的为我们指出了看待世界，处理关系的方式，那就是三分世界。不追求过阴过阳，而是阴阳协调，讲究合适。 中国式管理，研究的不是科学，而是哲学，中国处理哲学。如果你对中国式管理也感兴趣，曾仕强老师的演讲绝对是最具影响力的，上面的很多理解也只是老师思想的小碎片。下面挑选一些精彩之处，我相信总有些能让你醍醐灌顶之感。 人只有替自己做事才会效率很高的，替别人做事才会拖拖拉拉。组织如果能把团体弄得像一个人一样，效率就高了。毫无疑问，这句话讲出了管理的精髓。但是如何调动一个人的积极性和主动性，曾教授没有讲到。想起韩寒的那句：听了很多的大道理，却依然过不好一生。我们听了很多的“道”，从很少找到“术”，其实“道”和“术”是同样重要的。 我们不是被事情所困惑，我们是被我们自己对事情的看法所困惑。想起佛家的那首经典的楔子：不是风动，不是帆动，是你的心在动。这个世界是一样的，但是因为我们看待世界的角度不一样，导致我们认识的这个世界是不一样的。 中国式管理，讲起来就是水的管理。和美国式管理偏向火的管理颇为不同。我们主张以柔克刚，先礼后兵，继旧开新，生生不息，无一不和水有关。真的是这样的。中国人讲求面子工程，不给面子一定不行的。 结果不重要，原因、动机才重要。这句话很有意思，因为我们都是听过“对结果负责”这句话，但是曾教授反而说“结果不重要，原因、动机才重要”，我的理解是：做正确的事情比正确的做事要重要的多；如果方向对了，即使慢一点，终归会到达终点的。 中国人要走不会跟你讲真话的。他不是骗你，而是给你面子。好聚好散。人不可以欺骗，但是经常不能说真心话。说真心话你就更惨，比欺骗更惨。真的是这样的，所有说出要离职的人，给出的原因通常不是真正的原因，因为中国人真的需要留下“面子”。 曾仕强老师的《中国式管理》资源链接地址https://pan.baidu.com/s/1l0kJah9Wkam8CSLaGq4bvw 密码:xaf6","link":"/2019/08/27/2019-08-27-%E6%9B%BE%E5%A3%AB%E5%BC%BA%E4%B8%AD%E5%9B%BD%E5%BC%8F%E7%AE%A1%E7%90%86/"},{"title":"Git指令整理","text":"随便整理的一些自用的Git指令 GitHub创建仓库提示代码echo &quot;# 项目名&quot; &gt;&gt; README.md git init git add README.md git commit -m &quot;first commit&quot; git remote add origin git@github.com:qiubaiying/项目名.git git push -u origin master若仓库存在直接push git remote add origin git@github.com:qiubaiying/test.git git push -u origin master常用操作创建仓库（初始化）在当前指定目录下创建 git init 新建一个仓库目录 git init [project-name] 克隆一个远程项目 git clone [url]添加文件到缓存区添加所有变化的文件 git add . 添加名称指定文件 git add text.txt配置设置提交代码时的用户信息 git config [--global] user.name &quot;[name]&quot; git config [--global] user.email &quot;[email address]&quot;提交提交暂存区到仓库区 git commit -m &quot;msg&quot; # 提交暂存区的指定文件到仓库区 $ git commit [file1] [file2] ... -m [message] # 提交工作区自上次commit之后的变化，直接到仓库区 $ git commit -a # 提交时显示所有diff信息 $ git commit -v # 使用一次新的commit，替代上一次提交 # 如果代码没有任何新变化，则用来改写上一次commit的提交信息 $ git commit --amend -m [message] # 重做上一次commit，并包括指定文件的新变化 $ git commit --amend [file1] [file2] ...远程同步# 下载远程仓库的所有变动 $ git fetch [remote] # 显示所有远程仓库 $ git remote -v # 显示某个远程仓库的信息 $ git remote show [remote] # 增加一个新的远程仓库，并命名 $ git remote add [shortname] [url] # 取回远程仓库的变化，并与本地分支合并 $ git pull [remote] [branch] # 上传本地指定分支到远程仓库 $ git push [remote] [branch] # 强行推送当前分支到远程仓库，即使有冲突 $ git push [remote] --force # 推送所有分支到远程仓库 $ git push [remote] --all分支# 列出所有本地分支 $ git branch # 列出所有远程分支 $ git branch -r # 列出所有本地分支和远程分支 $ git branch -a # 新建一个分支，但依然停留在当前分支 $ git branch [branch-name] # 新建一个分支，并切换到该分支 $ git checkout -b [branch] # 新建一个分支，指向指定commit $ git branch [branch] [commit] # 新建一个分支，与指定的远程分支建立追踪关系 $ git branch --track [branch] [remote-branch] # 切换到指定分支，并更新工作区 $ git checkout [branch-name] # 切换到上一个分支 $ git checkout - # 建立追踪关系，在现有分支与指定的远程分支之间 $ git branch --set-upstream [branch] [remote-branch] # 合并指定分支到当前分支 $ git merge [branch] # 选择一个commit，合并进当前分支 $ git cherry-pick [commit] # 删除分支 $ git branch -d [branch-name] # 删除远程分支 $ git push origin --delete [branch-name] $ git branch -dr [remote/branch]标签Tags添加标签 在当前commit git tag -a v1.0 -m &apos;xxx&apos; 添加标签 在指定commit git tag v1.0 [commit] 查看 git tag 删除 git tag -d V1.0 删除远程tag git push origin :refs/tags/[tagName] 推送 git push origin --tags 拉取 git fetch origin tag V1.0 新建一个分支，指向某个tag git checkout -b [branch] [tag]查看信息# 显示有变更的文件 $ git status # 显示当前分支的版本历史 $ git log # 显示commit历史，以及每次commit发生变更的文件 $ git log --stat # 搜索提交历史，根据关键词 $ git log -S [keyword] # 显示某个commit之后的所有变动，每个commit占据一行 $ git log [tag] HEAD --pretty=format:%s # 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件 $ git log [tag] HEAD --grep feature # 显示某个文件的版本历史，包括文件改名 $ git log --follow [file] $ git whatchanged [file] # 显示指定文件相关的每一次diff $ git log -p [file] # 显示过去5次提交 $ git log -5 --pretty --oneline # 显示所有提交过的用户，按提交次数排序 $ git shortlog -sn # 显示指定文件是什么人在什么时间修改过 $ git blame [file] # 显示暂存区和工作区的差异 $ git diff # 显示暂存区和上一个commit的差异 $ git diff --cached [file] # 显示工作区与当前分支最新commit之间的差异 $ git diff HEAD # 显示两次提交之间的差异 $ git diff [first-branch]...[second-branch] # 显示今天你写了多少行代码 $ git diff --shortstat &quot;@{0 day ago}&quot; # 显示某次提交的元数据和内容变化 $ git show [commit] # 显示某次提交发生变化的文件 $ git show --name-only [commit] # 显示某次提交时，某个文件的内容 $ git show [commit]:[filename] # 显示当前分支的最近几次提交 $ git reflog撤销# 恢复暂存区的指定文件到工作区 $ git checkout [file] # 恢复某个commit的指定文件到暂存区和工作区 $ git checkout [commit] [file] # 恢复暂存区的所有文件到工作区 $ git checkout . # 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变 $ git reset [file] # 重置暂存区与工作区，与上一次commit保持一致 $ git reset --hard # 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变 $ git reset [commit] # 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致 $ git reset --hard [commit] # 重置当前HEAD为指定commit，但保持暂存区和工作区不变 $ git reset --keep [commit] # 新建一个commit，用来撤销指定commit # 后者的所有变化都将被前者抵消，并且应用到当前分支 $ git revert [commit] # 暂时将未提交的变化移除，稍后再移入 $ git stash $ git stash pop其他# 生成一个可供发布的压缩包 $ git archives","link":"/2019/11/23/2019-11-23-Git%E6%8C%87%E4%BB%A4%E6%95%B4%E7%90%86/"},{"title":"Spring ioc之深入理解IOC","text":"Spring— IOC之深入理解IOC在一开始学习 Spring 的时候，我们就接触 IoC 了，作为 Spring 第一个最核心的概念，我们在解读它源码之前一定需要对其有深入的认识，本篇为Spring系列博客的第一篇博文，主要介绍 IoC 基本概念和各个组件。 IOC理论IoC 全称为 Inversion of Control，翻译为 “控制反转”，它还有一个别名为 DI（Dependency Injection）,即依赖注入。 如何理解“控制反转”好呢？理解好它的关键在于我们需要回答如下四个问题： 谁控制谁 控制什么 为何是反转 哪些方面反转了 在回答这四个问题之前，我们先看 IOC 的定义： 所谓 IOC ，就是由 Spring IOC 容器来负责对象的生命周期和对象之间的关系 上面这句话是整个 IoC 理论的核心。如何来理解这句话？我们引用一个例子来走阐述（看完该例子上面四个问题也就不是问题了）。 已找女朋友为例（对于程序猿来说这个值得探究的问题）。一般情况下我们是如何来找女朋友的呢？首先我们需要根据自己的需求（漂亮、身材好、性格好）找一个妹子，然后到处打听她的兴趣爱好、微信、电话号码，然后各种投其所好送其所要，最后追到手。如下： 123456789101112131415161718192021222324/** * 年轻小伙子 */public class YoungMan { private BeautifulGirl beautifulGirl; YoungMan(){ // 可能你比较牛逼，指腹为婚 // beautifulGirl = new BeautifulGirl(); } public void setBeautifulGirl(BeautifulGirl beautifulGirl) { this.beautifulGirl = beautifulGirl; } public static void main(String[] args){ YoungMan you = new YoungMan(); BeautifulGirl beautifulGirl = new BeautifulGirl(\"你的各种条件\"); beautifulGirl.setxxx(\"各种投其所好\"); // 然后你有女票了 you.setBeautifulGirl(beautifulGirl); }} 这就是我们通常做事的方式，如果我们需要某个对象，一般都是采用这种直接创建的方式(new BeautifulGirl())，这个过程复杂而又繁琐，而且我们必须要面对每个环节，同时使用完成之后我们还要负责销毁它，在这种情况下我们的对象与它所依赖的对象耦合在一起。 其实我们需要思考一个问题？我们每次用到自己依赖的对象真的需要自己去创建吗？我们知道，我们依赖对象其实并不是依赖该对象本身，而是依赖它所提供的服务，只要在我们需要它的时候，它能够及时提供服务即可，至于它是我们主动去创建的还是别人送给我们的，其实并不是那么重要。再说了，相比于自己千辛万苦去创建它还要管理、善后而言，直接有人送过来是不是显得更加好呢？ 这个给我们送东西的“人” 就是 IoC，在上面的例子中，它就相当于一个婚介公司，作为一个婚介公司它管理着很多男男女女的资料，当我们需要一个女朋友的时候，直接跟婚介公司提出我们的需求，婚介公司则会根据我们的需求提供一个妹子给我们，我们只需要负责谈恋爱，生猴子就行了。你看，这样是不是很简单明了。 诚然，作为婚介公司的 IoC 帮我们省略了找女朋友的繁杂过程，将原来的主动寻找变成了现在的被动接受（符合我们的要求），更加简洁轻便。你想啊，原来你还得鞍马前后，各种巴结，什么东西都需要自己去亲力亲为，现在好了，直接有人把现成的送过来，多么美妙的事情啊。所以，简单点说，IoC 的理念就是让别人为你服务. 在没有引入 IoC 的时候，被注入的对象直接依赖于被依赖的对象，有了 IoC 后，两者及其他们的关系都是通过 Ioc Service Provider 来统一管理维护的。被注入的对象需要什么，直接跟 IoC Service Provider 打声招呼，后者就会把相应的被依赖对象注入到被注入的对象中，从而达到 IOC Service Provider 为被注入对象服务的目的。所以 IoC 就是这么简单！原来是需要什么东西自己去拿，现在是需要什么东西让别人（IOC Service Provider）送过来 现在在看上面那四个问题，答案就显得非常明显了: 谁控制谁：在传统的开发模式下，我们都是采用直接 new 一个对象的方式来创建对象，也就是说你依赖的对象直接由你自己控制，但是有了 IOC 容器后，则直接由 IoC 容器来控制。所以“谁控制谁”，当然是 IoC 容器控制对象。 控制什么：控制对象。 为何是反转：没有 IoC 的时候我们都是在自己对象中主动去创建被依赖的对象，这是正转。但是有了 IoC 后，所依赖的对象直接由 IoC 容器创建后注入到被注入的对象中，依赖的对象由原来的主动获取变成被动接受，所以是反转。 哪些方面反转了：所依赖对象的获取被反转了。 妹子有了，但是如何拥有妹子呢？这也是一门学问。 可能你比较牛逼，刚刚出生的时候就指腹为婚了。 大多数情况我们还是会考虑自己想要什么样的妹子，所以还是需要向婚介公司打招呼的。 还有一种情况就是，你根本就不知道自己想要什么样的妹子，直接跟婚介公司说，我就要一个这样的妹子。 所以，IOC Service Provider 为被注入对象提供被依赖对象也有如下几种方式：构造方法注入、stter方法注入、接口注入。 构造器注入 构造器注入，顾名思义就是被注入的对象通过在其构造方法中声明依赖对象的参数列表，让外部知道它需要哪些依赖对象。 123YoungMan(BeautifulGirl beautifulGirl){ this.beautifulGirl = beautifulGirl;} 构造器注入方式比较直观，对象构造完毕后就可以直接使用，这就好比你出生你家里就给你指定了你媳妇。 setter 方法注入 对于 JavaBean 对象而言，我们一般都是通过 getter 和 setter 方法来访问和设置对象的属性。所以，当前对象只需要为其所依赖的对象提供相对应的 setter 方法，就可以通过该方法将相应的依赖对象设置到被注入对象中。如下： 1234567public class YoungMan { private BeautifulGirl beautifulGirl; public void setBeautifulGirl(BeautifulGirl beautifulGirl) { this.beautifulGirl = beautifulGirl; }} 相比于构造器注入，setter 方式注入会显得比较宽松灵活些，它可以在任何时候进行注入（当然是在使用依赖对象之前），这就好比你可以先把自己想要的妹子想好了，然后再跟婚介公司打招呼，你可以要林志玲款式的，赵丽颖款式的，甚至凤姐哪款的，随意性较强。 接口方式注入 接口方式注入显得比较霸道，因为它需要被依赖的对象实现不必要的接口，带有侵入性。一般都不推荐这种方式。 各个组件 该图为 ClassPathXmlApplicationContext 的类继承体系结构，虽然只有一部分，但是它基本上包含了 IOC 体系中大部分的核心类和接口。 下面我们就针对这个图进行简单的拆分和补充说明。 Resource体系 Resource，对资源的抽象，它的每一个实现类都代表了一种资源的访问策略，如ClasspathResource 、 URLResource ，FileSystemResource 等。 有了资源，就应该有资源加载，Spring 利用 ResourceLoader 来进行统一资源加载. BeanFactory 体系 BeanFactory 是一个非常纯粹的 bean 容器，它是 IOC 必备的数据结构，其中 BeanDefinition 是她的基本结构，它内部维护着一个 BeanDefinition map ，并可根据 BeanDefinition 的描述进行 bean 的创建和管理。 BeanFacoty 有三个直接子类 ListableBeanFactory、HierarchicalBeanFactory 和 AutowireCapableBeanFactory，DefaultListableBeanFactory 为最终默认实现，它实现了所有接口。 Beandefinition 体系 BeanDefinition 用来描述 Spring 中的 Bean 对象。 BeandefinitionReader体系 BeanDefinitionReader 的作用是读取 Spring 的配置文件的内容，并将其转换成 Ioc 容器内部的数据结构：BeanDefinition。 ApplicationContext体系 这个就是大名鼎鼎的 Spring 容器，它叫做应用上下文，与我们应用息息相关，它继承 BeanFactory，所以它是 BeanFactory 的扩展升级版，如果BeanFactory 是屌丝的话，那么 ApplicationContext 则是名副其实的高富帅。由于 ApplicationContext 的结构就决定了它与 BeanFactory 的不同，其主要区别有： 继承 MessageSource，提供国际化的标准访问策略。 继承 ApplicationEventPublisher ，提供强大的事件机制。 扩展 ResourceLoader，可以用来加载多个 Resource，可以灵活访问不同的资源。 对 Web 应用的支持。","link":"/2019/11/25/2019-11-25-Spring%20ioc%E4%B9%8B%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ioc/"}],"tags":[{"name":"曾士强","slug":"曾士强","link":"/tags/%E6%9B%BE%E5%A3%AB%E5%BC%BA/"},{"name":"中国式管理","slug":"中国式管理","link":"/tags/%E4%B8%AD%E5%9B%BD%E5%BC%8F%E7%AE%A1%E7%90%86/"},{"name":"终端","slug":"终端","link":"/tags/%E7%BB%88%E7%AB%AF/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"ioc","slug":"ioc","link":"/tags/ioc/"},{"name":"Spring","slug":"Spring","link":"/tags/Spring/"}],"categories":[{"name":"资料","slug":"资料","link":"/categories/%E8%B5%84%E6%96%99/"},{"name":"git","slug":"git","link":"/categories/git/"},{"name":"Spring","slug":"Spring","link":"/categories/Spring/"}]}