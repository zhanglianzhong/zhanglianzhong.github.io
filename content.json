{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/11/23/hello-world/"},{"title":"曾士强中国式管理","text":"曾士强中国式管理不想当将军的士兵肯定不是好士兵，我相信绝大部分朋友都是希望某天能走向管理岗位，而不是一味的在最底层靠卖体力卖技术营生。那从现在起，掌握一些管理知识，是非常有必要的。 中国的高校教育，很大程度上，是延续了西方那套二分思维模式，非黑即白。这种思维模式，在搞科学研究时，是非常适合的，毕竟科学容不得半点虚假，追求的也是终极真理。然而，在面临管理问题时，尤其是你是一个中国人，每天面对的也是形形色色被中华文化熏陶成长起来的中国人，在一个法治还在建设全是人情的社会，你还用西方那种二分思维方式，你肯定是要吃亏的。 举个最简单的例子，西方从古希腊时期，就开始提倡辩论文化，他们相信真理越辩越明。然而，在中国，遇到事情，不讲还好，越讲越乱，讲到最后大家都糊涂了。 西方人讲能力，中国人不讲能力。我们讲本事不讲能力。有能力没有本事的人迟早是个问题人物。什么叫本事？有能力还要加上受到大家的欢迎才叫本事。有能力到处标新立异，处处让人家看不顺眼，这个人迟早是个闯祸的人。有能力还要尊重别人，让别人有面子，他就会支持你。 西方二分看待世界，对就是对，错就是错，黑就是黑，白就是白。太极图很好的为我们指出了看待世界，处理关系的方式，那就是三分世界。不追求过阴过阳，而是阴阳协调，讲究合适。 中国式管理，研究的不是科学，而是哲学，中国处理哲学。如果你对中国式管理也感兴趣，曾仕强老师的演讲绝对是最具影响力的，上面的很多理解也只是老师思想的小碎片。下面挑选一些精彩之处，我相信总有些能让你醍醐灌顶之感。 人只有替自己做事才会效率很高的，替别人做事才会拖拖拉拉。组织如果能把团体弄得像一个人一样，效率就高了。毫无疑问，这句话讲出了管理的精髓。但是如何调动一个人的积极性和主动性，曾教授没有讲到。想起韩寒的那句：听了很多的大道理，却依然过不好一生。我们听了很多的“道”，从很少找到“术”，其实“道”和“术”是同样重要的。 我们不是被事情所困惑，我们是被我们自己对事情的看法所困惑。想起佛家的那首经典的楔子：不是风动，不是帆动，是你的心在动。这个世界是一样的，但是因为我们看待世界的角度不一样，导致我们认识的这个世界是不一样的。 中国式管理，讲起来就是水的管理。和美国式管理偏向火的管理颇为不同。我们主张以柔克刚，先礼后兵，继旧开新，生生不息，无一不和水有关。真的是这样的。中国人讲求面子工程，不给面子一定不行的。 结果不重要，原因、动机才重要。这句话很有意思，因为我们都是听过“对结果负责”这句话，但是曾教授反而说“结果不重要，原因、动机才重要”，我的理解是：做正确的事情比正确的做事要重要的多；如果方向对了，即使慢一点，终归会到达终点的。 中国人要走不会跟你讲真话的。他不是骗你，而是给你面子。好聚好散。人不可以欺骗，但是经常不能说真心话。说真心话你就更惨，比欺骗更惨。真的是这样的，所有说出要离职的人，给出的原因通常不是真正的原因，因为中国人真的需要留下“面子”。 曾仕强老师的《中国式管理》资源链接地址https://pan.baidu.com/s/1l0kJah9Wkam8CSLaGq4bvw 密码:xaf6","link":"/2019/08/27/2019-08-27-%E6%9B%BE%E5%A3%AB%E5%BC%BA%E4%B8%AD%E5%9B%BD%E5%BC%8F%E7%AE%A1%E7%90%86/"},{"title":"Git指令整理","text":"随便整理的一些自用的Git指令 GitHub创建仓库提示代码echo &quot;# 项目名&quot; &gt;&gt; README.md git init git add README.md git commit -m &quot;first commit&quot; git remote add origin git@github.com:qiubaiying/项目名.git git push -u origin master若仓库存在直接push git remote add origin git@github.com:qiubaiying/test.git git push -u origin master常用操作创建仓库（初始化）在当前指定目录下创建 git init 新建一个仓库目录 git init [project-name] 克隆一个远程项目 git clone [url]添加文件到缓存区添加所有变化的文件 git add . 添加名称指定文件 git add text.txt配置设置提交代码时的用户信息 git config [--global] user.name &quot;[name]&quot; git config [--global] user.email &quot;[email address]&quot;提交提交暂存区到仓库区 git commit -m &quot;msg&quot; # 提交暂存区的指定文件到仓库区 $ git commit [file1] [file2] ... -m [message] # 提交工作区自上次commit之后的变化，直接到仓库区 $ git commit -a # 提交时显示所有diff信息 $ git commit -v # 使用一次新的commit，替代上一次提交 # 如果代码没有任何新变化，则用来改写上一次commit的提交信息 $ git commit --amend -m [message] # 重做上一次commit，并包括指定文件的新变化 $ git commit --amend [file1] [file2] ...远程同步# 下载远程仓库的所有变动 $ git fetch [remote] # 显示所有远程仓库 $ git remote -v # 显示某个远程仓库的信息 $ git remote show [remote] # 增加一个新的远程仓库，并命名 $ git remote add [shortname] [url] # 取回远程仓库的变化，并与本地分支合并 $ git pull [remote] [branch] # 上传本地指定分支到远程仓库 $ git push [remote] [branch] # 强行推送当前分支到远程仓库，即使有冲突 $ git push [remote] --force # 推送所有分支到远程仓库 $ git push [remote] --all分支# 列出所有本地分支 $ git branch # 列出所有远程分支 $ git branch -r # 列出所有本地分支和远程分支 $ git branch -a # 新建一个分支，但依然停留在当前分支 $ git branch [branch-name] # 新建一个分支，并切换到该分支 $ git checkout -b [branch] # 新建一个分支，指向指定commit $ git branch [branch] [commit] # 新建一个分支，与指定的远程分支建立追踪关系 $ git branch --track [branch] [remote-branch] # 切换到指定分支，并更新工作区 $ git checkout [branch-name] # 切换到上一个分支 $ git checkout - # 建立追踪关系，在现有分支与指定的远程分支之间 $ git branch --set-upstream [branch] [remote-branch] # 合并指定分支到当前分支 $ git merge [branch] # 选择一个commit，合并进当前分支 $ git cherry-pick [commit] # 删除分支 $ git branch -d [branch-name] # 删除远程分支 $ git push origin --delete [branch-name] $ git branch -dr [remote/branch]标签Tags添加标签 在当前commit git tag -a v1.0 -m &apos;xxx&apos; 添加标签 在指定commit git tag v1.0 [commit] 查看 git tag 删除 git tag -d V1.0 删除远程tag git push origin :refs/tags/[tagName] 推送 git push origin --tags 拉取 git fetch origin tag V1.0 新建一个分支，指向某个tag git checkout -b [branch] [tag]查看信息# 显示有变更的文件 $ git status # 显示当前分支的版本历史 $ git log # 显示commit历史，以及每次commit发生变更的文件 $ git log --stat # 搜索提交历史，根据关键词 $ git log -S [keyword] # 显示某个commit之后的所有变动，每个commit占据一行 $ git log [tag] HEAD --pretty=format:%s # 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件 $ git log [tag] HEAD --grep feature # 显示某个文件的版本历史，包括文件改名 $ git log --follow [file] $ git whatchanged [file] # 显示指定文件相关的每一次diff $ git log -p [file] # 显示过去5次提交 $ git log -5 --pretty --oneline # 显示所有提交过的用户，按提交次数排序 $ git shortlog -sn # 显示指定文件是什么人在什么时间修改过 $ git blame [file] # 显示暂存区和工作区的差异 $ git diff # 显示暂存区和上一个commit的差异 $ git diff --cached [file] # 显示工作区与当前分支最新commit之间的差异 $ git diff HEAD # 显示两次提交之间的差异 $ git diff [first-branch]...[second-branch] # 显示今天你写了多少行代码 $ git diff --shortstat &quot;@{0 day ago}&quot; # 显示某次提交的元数据和内容变化 $ git show [commit] # 显示某次提交发生变化的文件 $ git show --name-only [commit] # 显示某次提交时，某个文件的内容 $ git show [commit]:[filename] # 显示当前分支的最近几次提交 $ git reflog撤销# 恢复暂存区的指定文件到工作区 $ git checkout [file] # 恢复某个commit的指定文件到暂存区和工作区 $ git checkout [commit] [file] # 恢复暂存区的所有文件到工作区 $ git checkout . # 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变 $ git reset [file] # 重置暂存区与工作区，与上一次commit保持一致 $ git reset --hard # 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变 $ git reset [commit] # 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致 $ git reset --hard [commit] # 重置当前HEAD为指定commit，但保持暂存区和工作区不变 $ git reset --keep [commit] # 新建一个commit，用来撤销指定commit # 后者的所有变化都将被前者抵消，并且应用到当前分支 $ git revert [commit] # 暂时将未提交的变化移除，稍后再移入 $ git stash $ git stash pop其他# 生成一个可供发布的压缩包 $ git archives","link":"/2019/11/23/2019-11-23-Git%E6%8C%87%E4%BB%A4%E6%95%B4%E7%90%86/"}],"tags":[{"name":"曾士强","slug":"曾士强","link":"/tags/%E6%9B%BE%E5%A3%AB%E5%BC%BA/"},{"name":"中国式管理","slug":"中国式管理","link":"/tags/%E4%B8%AD%E5%9B%BD%E5%BC%8F%E7%AE%A1%E7%90%86/"},{"name":"Mac","slug":"Mac","link":"/tags/Mac/"},{"name":"终端","slug":"终端","link":"/tags/%E7%BB%88%E7%AB%AF/"},{"name":"Git","slug":"Git","link":"/tags/Git/"}],"categories":[]}